# Бинарный поиск
Работает **только** в отсортированном массиве\
![](img/binarysearch.png)
```java
public class BinarySearcher {
    ...
    public <T extends Comparable<T>> int find(T[] elements, T element) {
        int lowIndex = 0; // Нижняя граница
        int highIndex = elements.length - 1; // Верхняя граница
        Integer resultIndex = null;

        while (lowIndex <= highIndex) {
            int middleIndex = (lowIndex + highIndex) / 2; // Берем индекс середины интервала
            T guessElement = elements[middleIndex]; // Берем элемент из середины
            if (guessElement.equals(element)) {
                resultIndex =  middleIndex;
                break;
            } else if (guessElement.compareTo(element) > 0) {
                highIndex = middleIndex - 1;
            } else {
                lowIndex = middleIndex + 1;
            }
        }

        return resultIndex;
    }
}
```
[Исходник](examples/java/binary/BinarySearcher.java)\
_Бхаргава А. Грокаем алгоритмы. 2-е изд. Стр. 32-36_

## Скорость поиска в сравнении с простым поиском
Если поиск перебором отрабатывает за `O(n)`, то поиск бинарным поиском осуществляется за `O(log n)` 

| Количество элементов | Простой поиск               | Бинарный поиск                     |
|----------------------|-----------------------------|------------------------------------|
| 100                  | 100 попыток                 | 7 попыток                          |
| 4 000 000 000        | 4000000000 попыток          | 32 попытоки                        |
|        | **Линейное время<br/>O(n)** | **Логарифмическое время<br/>O(Log n)** |



_Бхаргава А. Грокаем алгоритмы. 2-е изд. Стр. 37_