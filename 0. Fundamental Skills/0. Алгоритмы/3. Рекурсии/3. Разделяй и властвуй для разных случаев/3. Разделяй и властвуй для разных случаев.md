# Разделяй и властвуй как подход
Разделяй и властвуй - не просто алгоритм, а скорее подход к решению задач.\
Можно вполне применять для замены циклов в функциональном программировании, где циклов может не быть.\
_Бхаргава А. Грокаем алгоритмы. 2-е изд. Стр. 92-93_

## Бинарный поиск на рекурсии
```java
public class BinarySearcherViaRecursion <T extends Comparable<T>> {
    public int find(T element, T... elements) {
        return findRecursively(element, elements, 0, elements.length - 1);
    }

    private int findRecursively(T element, T[] elements, int startPosition, int endPosition) {
        int middleIndex = startPosition + ((endPosition - startPosition) / 2);
        if (element.equals(elements[middleIndex])) {
            return middleIndex;
        } else if (element.compareTo(elements[middleIndex]) > 0) {
            return findRecursively(element, elements, middleIndex + 1, endPosition);
        } else {
            return findRecursively(element, elements, startPosition, middleIndex - 1);
        }
    }
}
```
[Исходник](examples/java/binary_search/BinarySearcherViaRecursion.java)

## Суммирование на рекурсии
```java
public class SumViaRecursionCalculator {
    public int calculate(int... numbers) {
        return recursiveSumCalculator(numbers);
    }

    private int recursiveSumCalculator(int... numbers) {
        if (numbers.length == 1) {
            return numbers[0];
        } else {
            int[] newNumbers = new int[numbers.length - 1];
            System.arraycopy(numbers, 1, newNumbers, 0, numbers.length - 1);
            return numbers[0] + recursiveSumCalculator(newNumbers);
        }
    }
}
```
[Исходник](examples/java/sum/SumViaRecursionCalculator.java)\
_Бхаргава А. Грокаем алгоритмы. 2-е изд. Стр. 92-94_

## Поиск максимума на рекурсии
```java
public class MaxCiaRecursionCalculator {
    public int calculate(int... numbers) {
        return recursiveMaxCalculator(numbers);
    }

    private int recursiveMaxCalculator(int... numbers) {
        if (numbers.length == 1) {
            return numbers[0];
        } else {
            int[] newNumbers = new int[numbers.length - 1];
            System.arraycopy(numbers, 1, newNumbers, 0, numbers.length - 1);
            int recursivedMax = recursiveMaxCalculator(newNumbers);
            return (numbers[0] >= recursivedMax) ? numbers[0] : recursivedMax;
        }
    }
}
```
[Исходник](examples/java/max/MaxCiaRecursionCalculator.java)

## Подсчет элементов на рекурсии
```java
public class CountViaRecursionCalculator {
    public int calculate(int... numbers) {
        return recursiveCountCalculator(numbers);
    }

    private int recursiveCountCalculator(int... numbers) {
        if (numbers.length == 1) {
            return 1;
        } else {
            int[] newNumbers = new int[numbers.length - 1];
            System.arraycopy(numbers, 1, newNumbers, 0, numbers.length - 1);
            return 1 + recursiveCountCalculator(newNumbers);
        }
    }
}
```
[Исходник](examples/java/count/CountViaRecursionCalculator.java)