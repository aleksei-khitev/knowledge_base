## Операторы
### Игра скобками при выводе конкатенированной строки и значений
```java
int x = 0;
int y = 1;
int z = 2;
String s = "x, y, z = ";
System.out.println(s + x + y + z);
// > x, y, z = 012
```
Все переменные преобразуются к строке и результат идет на вход `System.out.println(...)`
```java
int x = 0;
int y = 1;
int z = 2;
String s = "x, y, z = ";
System.out.println(s + (x + y + z) );
// > x, y, z = 3
```
Вначале происходит сложение в скобках, а потом уже приведение к строке.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 115_

### Ошибка компилятора защитит от `=` вместо `==` в `while` и от `&` вместо `&&` (и других подобных)
```java
int x = 0;
int y = 1;
...
while(x = y) {
...
}
```
`while` ожидает на входе `boolean`, а в результате выражение получается `int`. Из-за этого копилятор выдаст ошибку, чем защитит от распространенной ошибки в других языках.<br/>
Аналогично для операторов `&` и `|` вместо `&&` и `||`.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 115-116_

### Приведение float и double к целочисленным всегда с усечением
```java
double above = 0.7;
float below = 0.4f;
System.out.println((int)above);
System.out.println((int)below);
// > 0
// > 0
```
Для того, чтобы было округление значения нужно использовать `java.lang.Math.round()`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 117_

### При переполнении переменной не возникнет исключений
```java
int big = Integer.MAX_VALUE;
System.out.println(big);
int bigger = big * 4;
System.out.println(bigger);
// > 2147483647
// > -4
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 126_

## Конвертация времени
```java
TimeUnit.NANOSECONDS.convert(someValue, TimeUnit.MILLISECONDS)
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 989_

## Расширенное выведение типов
В последних версиях, Java эволюционировала так, чтобы шире использовать **выведение типов** (`type inference`)\
Оно позволяет компилятору определить часть нужной информации автоматически, чтолбы не приходилось писать ее явно.\
Тенденция началась в Java 5 с появлением обощений.\
Продолжилась в Java 7 с необязательностью дублирования определения обобщений.\
Далее, в Java 8 добавились лямбда-выражения.\
И, наконец, в Java 10 добавилось ключевое слово `var` (LVTI - Local Variable Type Inference)\
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 45-46_

## var
Синтаксис `var` предназначен для того, чтобы сократить объекм кода на Java.\
Он не вводит динамическую типизацию. Каждой переменной Java по прежнему соответствует статический тип - просто его не всегда обязательно указывать явно.\
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 47_

### Когда полезен var
- простые инициализаторы, где правая часть - вызов конструктора или статического фабричного метода
- если удаление явного типа позволяет устранить избыточную дублирующую информацию
- если имена переменных уже обозначают их тип
- если локальная переменная действует и используется в простой и узкой области

Полный перечень рекомендация по ссылке: [Local Variable Type Inference  Style Guidelines](mng.bz/RvPK)\
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 48_

### Ограничения var
Выведение типов в Java действует **локально** и, в случае с `var`, алгоритм проверяет только объявления локальной переменной.\
Таким образом, `var` нельзя использовать для
- полей
- аргументов методов
- возвращаемых типов

Чтобы компилятор смог выводить типы, программист должен предоставить достаточно информации, которая позволит решить систему ограничивающих уравнений.\
К примеру, этот код не содержит достаточно информации для этого
```java
var fn = s -> s.length();
```
или
```java
var n = null;
```
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 47_

### var и производительность
`var` реализуется исключительно компилятором `javac` и никак не влияет на выполнение или быстродействие\
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 47_

## Однофайловое выполнение
В Java 11 внедрен JEP 330, который позволяет откомпилировать исходный код в памяти, а затем выполнить его интерпретатором даже не создавая .class-файл на диске.\
При запуске используется флаг `--source`, который обозначает режим совместимости\
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 61-62_

### Ограничения однофайлового выполнения
- Весь код должен находиться в одном файле
- Во время запуска не могут компилироваться дополнительные исходные файлы
- В исходном файле может быть сколько угодно классов
- Первый класс должен быть объявлен в исходном файле как точка входа
- В этом классе джолжен быть определен `main`

_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 62_

### Однофайловое выполнение и shebang
```sh
#!/usr/bin/java --source 11
public final class HTTP2Check {
  public static void main(String[] args) {
    // какая то логика 
  }
}
```
Благодаря использованию shebang, код можно выполнять напрямую
```sh
./HTTP2Check https://www.google.com
```
_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 62_