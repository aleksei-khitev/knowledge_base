# Строки
## Текстовые блоки
В Java 17 в рамках JEP 378 появились текстовые блоки, которые не только избавляют разработчиков от необходимости экранировать символы, но и специально разработаны так, чтобы с их помощью можно было создавать удобочитаемые строки кода на других языках и вставлять в программу на Java.\
К примеру, SQL или XML
```java
String query = """
        SELECT "ORDER_ID"
        FROM "ORDERS"
        WHERE "CLIENT_ID" = ?
        """;
```
Текстовые блоки обрабатываются компилятором `javac` перед тем, как константа записывается в файл класса
- символы перевода строки преобразуются в LF (`\u000A`), как принято в UNIX
- дополнительные пробелы вокруг блока удаляются
- все экранированные последовательности в блоке интерпретируются

_Б.Эванс, Java для опытных разработчиков. Второе издание. стр. 98-99_

## Конкатенация (`+`) компилируется в `StringBuilder`
Если декомпилировать (javap) код с конкатенацией, то можно увидеть, что компилятор создает и использует для этого `StringBuilder`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 415_

## Декомпиляция класса
Декомпилировать класс можно, вызвав команду `javap -c SomeClass`<br/>
Флаг `-c` генерирует байт-код JVM<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 415_

## Явный и генерируемый `StringBuilder` в циклах
В случае конкатенации строк в цикле компилятор генерирует `StringBuilder` внутри цилка. Таким образом, объект `StringBuilder` создается внутри каждой итерации<br/>
В случае явного создания `StringBuilder` перед циклом, эта проблема не возникает.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 416-417_

## Конкатенация внутри `StringBuilder`
В случае `someStringbuilder.append(a + ":" + b)`, компилятор сгенерирует **еще один** `StringBuilder`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 418_

## Методы `StringBuilder`
* `append`
* `insert`
* `replace`
* `substring`
* `delete`
* `reverse`

_Эккель Б. Философия Java. 4-е полное изд. Стр. 418_

## Методы `String`
* `length`
* `equals`, `equalsIgnoreCase`
* `getChars`, `getBytes`
* `charAt`
* `toCharArray`
* `contains`
* `contentEquals` (точное совпадение с аргументом), `equalsIgnoreCase`
* `indexOf`, `lastIndexOf`
* `startsWith`, `endsWith`
* `replace`
* `toLowerCase`, `toUpperCase`
* `trim`
* `valueOf`

_Эккель Б. Философия Java. 4-е полное изд. Стр. 420_

## Форматированный `System.out` с `format` и `printf`
```java
int x = 5;
douable y = 5.334;
System.out.format("Row 1: [%d %f]", x, y);
System.out.printf("Row 1: [%d %f]", x, y);
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 422_

## `Formatter`
`Formatter` приводит строку к нужному виду<br/>
В конструктор задается куда выводить `Formatter` (`OutputStream`, `PrintStream`, 'File'...)<br/>
При вызове `format` происходит форматирование
```java
Formatter formatter = new Formatter(System.out);
formatter.format("%s The Ship is at (%d,%d)", "Imperial Star Destroyer", 4, 8);
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 422_

## Форматные спецификаторы
`%[аргумент_индекс][флаги][ширина][.точность]преобразование`<br/>
* ширина - минимальный размер поля. Дополняется пробелами, если надо.
* флаги - По умолчанию, выравнивание справа. Но включив `-`, можно это переопределить
* точность - задает максимальное максимальное значение
* * для `String` задает максимальное количество символов
* * для вещественных чисел задает количество выводимых знаков с округлением или добавлением нулей (по умолчанию, 6)
* * для целых чисел применять точность **нельзя**. У них нет дробной части и при попытки применить точность, будет возбуждено _исключение_

```java
Formatter formatter = new Formatter(System.out);
formatter.format("%-15s %5s %10s\n", "Item", "Qty", "Price");
formatter.format("%-15s %5s %10s\n", "----", "---", "-----");
formatter.format("%-15.15s %5d %10.2f\n", "Jack's Magic Beans", 4, 4.25);
formatter.format("%-15.15s %5d %10.2f\n", "Princess Peas", 3, 5.1);
```
```
Item              Qty      Price
----              ---      -----
Jack's Magic Be     4       4,25
Princess Peas       3       5,10
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 423-424_

## Преобразования `Formatter`
* d - целое число (десятичное)

Символ | Расшифровка
-------|------------
d | Целое число (десятичное)
c | Символ Unicode
b | Логическое значение
s | Строка
f | Вещественное число (в десятичной записи)
e | Вещественное число (в экспоненциальной записи)
x | Целое число (в шестнадцатеричной записи)
h | Хэш-код (в шестнадцатеричной записи)
% | Литерал %

_Эккель Б. Философия Java. 4-е полное изд. Стр. 425_

## Сканирование ввода до Java5 через `StringReader`
```java
BufferedReader input new BufferedReader(new StringReader("Sir Robin\n22"));
System.out.println("What is your name?");
System.out.println(input.readLine());
System.out.println("How old are yyou?");
System.out.println(input.readLine());
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 446_

## Сканирование ввода c Java5 с использованием `Scanner`
```java
Scanner scanner = new Scanner(new BufferedReader(new StringReader("Sir Robin\n22")));
System.out.println("What is your name?");
System.out.println(scanner.nextLine());
System.out.println("How old are yyou?");
System.out.println(scanner.nextInt());
```
Конструктор `Scanner` может получать практически любые входные объекты, включая `File`, `InputStream`, `String`, `Readable`.<br/>
Разбивка на лексемы удобно разбивается по разным видам методов `next`. Просто `next` возвращает следующую лексему `String`.<br/>
Существуют еще вариации `next` для всех примитивных типов (кроме `char`), `BigDecimal`, `BigInteger`.<br/>
Существует метод `hasNext()`, который возвращает `true`, если следующая лексема правильного типа.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 447-448_

## Свои ограничители в `Scanner`
По умолчанию, сканер разбивает по пропускам, но можно добавить свои ограничители в форме регулярных выражений, по которым он будет разбивать
```java
Scanner scanner = new Scanner("1, 2, 3, 4, 5");
scanner.useDelimiter("\\s*", "\\s*");
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 448-449_