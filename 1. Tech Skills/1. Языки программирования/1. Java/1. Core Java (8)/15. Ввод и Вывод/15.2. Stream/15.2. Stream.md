# Stream
* [Сжатие данных (архивация/распаковка в zip/gzip)](15.2.1.%20Сжатие%20данных/15.2.1.%20Сжатие%20данных.md)
* [Сериализация](15.2.2.%20Сериализация/15.2.2.%20Сериализация.md)

## Идея потока (Stream)
В Java используется абстракция потока (_stream_) - произвольного источника или приемника данных, который способен производить или получать некоторую информацию. Поток скрывает подробности низкоуровневых операций, выполняемых с данными непосредственно в устройствах ввода/вывода.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 734_

## `InputStream` и его подклассы
Назначение базового класса `InputStream` - представлять классы, которые получают данные из различных источников (массив байт, String, файл, pipe (канал), другие источники).<br/>
Каждый из указанных источников имеет ассоциированный с ним подкласс базового класса `InputStream`<br/>
Дополнительно есть класс `FileInputStream`, который является производным от `InputStream` и представляет собой основу для классов-"декораторов", добавляющих к входным потокам полезные свойства и интерфейсы.
### Разновидности `InputStream`
| Класс | Назначение                                                                                                                | Аргументы конструктора /<br/>порядок применения |
| --- |---------------------------------------------------------------------------------------------------------------------------| --- |
| `ByteArrayInputStream` | Позволяет использовать массив байтов в качестве источника данных для входного потока                                      | Буфер из которого берутся данные |
| `StringBufferInputStream`<br/>Объявлен устаревшим | Превращает строку во входящий поток данных                                                                                | Строка.<br/>Лежащая в основе класса реализация на самом деле использует `StringBuffer` |
| `FileInputStream` | Для чтения информации из файла                                                                                            | Строка с именем, или `File` или `FileDescriptor` |
| `PipedInputStrem` | Производит данные, которые былизаписаны в соотвествующий выходной поток `PipedOutpuStream`<br/>Реализует концепцию канала | Объект `PipedOutputStream`<br/>Как источник данных в многозадачном окружении |
| `SequenceInputStream` | Сливает два или более потока `InputStream` в единый поток                                                                 | Два объекта-потока `InputStream` или перечисление `Enumiration` для контейнера, в котором содержатся все потоки |
| `FilterInputStream` | Абстрактный класс, предоставляющий интерфейс для классов-декораторов                                                      | |

Практически все их можно присоединить (как источник данных) к классу `FilterInputStream`, чтобы получить расширенные возможности и удобный интерфейс.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 734-736_

## Разновидности `FilterInputStream`
| Класс | Назначение | Аргументы конструктора /<br/>порядок применения |
| --- | --- | --- |
| `DataInputStream` | Используется в сочетании с классом `DataOutputStream`.<br/>Позволяет читать примитивы (int, long, char и т.д.) из потока без привязки к платформе (`readByte()`, `readFloat()`...) | `InputStream`.<br/>Содержит все необходимое для чтения всех примитивных типов. |
| `BufferedInputStream` | Используется для предотвращения физического чтения с устройства при каждом новом запросе данных. | `InputStream` и размер буффера (необязательно).<br/> |
| `LineNumberInputStream` | Следит за количеством считанных из потока строк.<br/>Их число можно узнать, вызвав метод `getLineNumber`<br/>Перейти к нужной строке можно вызвав метод `setLineNumber(...)` | `InputStream` |
| `PushbackInputStream` | Имеет односимвольный буффер, который позволяет помещать в поток только что считанный символ | `InputStream`<br/>Обычно используется при сканировании айлов для компилятора |

_Эккель Б. Философия Java. 4-е полное изд. Стр. 737-738_

## `OutputStream` и его подклассы
Определяет, куда направляются данные: массив байт, файл, канал.<br/>
Нельзя использовать `String` напрямую. Предполагается воссоздание их из массива байт.<br/>
Вдобавок, `FilterOutputStream` предоставляет базовый интерфейс для классов-"декораторов", которые способны добавлять к существующим потокам полезные свойства и интерфейсы.
### Разновидности
| Класс | Назначение | Аргументы конструктора /<br/>порядок применения |
| --- | --- | --- |
| `ByteArrayOutputStream` | Создает буфер в памяти.<br/>Все данные, посылаемые в этот поток, разещаются в созданном буффере | Начальный размер буффера (необязательный аргумент) |
| `FileOutputStream` | Отправка данных в файл | Строка с именем, или `File` или `FileDescriptor` |
| `PipedOutputStream` | Все данные, записанные в поток, автоматически появляются в ассоциированном с ним входном потоке `PipedInputStream`<br/>Реализует понятие канала | Объект `PipedInputStream` |
| `FilterOutputStream` | Абстрактный класс, предоставляющий интерфейс для классов-декораторов | |

_Эккель Б. Философия Java. 4-е полное изд. Стр. 736_

## Разновидности `FilterOutputStream`
| Класс | Назначение | Аргументы конструктора /<br/>порядок применения |
| --- | --- | --- |
| `DataOutputStream` | Используется в сочетании с `DataInputStream`<br/>Позволяет записывать в поток примитивы независимо от платформы | `OutputStream` |
| `PrintStream` | Используется для форматирования данных при выводе.<br/>Если класс `dataOutputStream` отвечает за хранение данных, то этот класс отвечает за отображение данных | `OutputStream` и флаг `boolean`, показывающий, нужно ли очищать буффер при переходе на новую строку<br/>Должен быть последним в "наслоении" объектов `OutputStream` |
| `BufferedOutputStream` | Испоьзуется для буфферезации, то есть для предотращения прямой записи в устройство каждый раз при записи данных<br/>Для записи содержимого буффера используется метод `flush()` | `OutpustStream` и размер буффера (необязательно) |

_Эккель Б. Философия Java. 4-е полное изд. Стр. 739_

## Проблема `PrintStream`
На практике, `PrintStream` довольно неудобен, так как он перехватывает все исключения `IOException`.<br/>
Приходится явно вызывать метод `checkError()`, который возвращает `true`, если произошла ошибка<br/>
К тому же, интернационализация этого класса выполнена недостаточно качественно и он не обрабатывает перевод строки платформенно-независимым образом.<br/>
Все эти проблемы решены в `PrintWriter`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 739_

## Усложнение из-за декораторов
Декораторы предоставляют дополнительную гибкость при написании программы, но при этом код получается излишне сложным.<br/>
Причина запутанности библиотеки ввода/вывода в java состоит в том, что для получения желаемого объекта приходится создавать много дополнительных объектов - "ядро" ввода/вывода и набор декораторов.<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 737_

## Проверка завершения потока у `DataInputStream`
[Пример](examples/java/io/stream/DataInputStreamAvailability.java)
```java
String testString = "123456789";
byte[] testBytes = testString.getBytes();
try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(testBytes);
     BufferedInputStream bufferedInputStream = new BufferedInputStream(byteArrayInputStream);
     DataInputStream dataInputStream = new DataInputStream(bufferedInputStream)) {
    while (dataInputStream.available() != 0) {
        System.out.print((char) dataInputStream.readByte());
    }
} catch (IOException e) {}
```
Вывод
```
123456789
```
_Эккель Б. Философия Java. 4-е полное изд. Стр. 746_

## `DataInputStream`, `DataOutputStream` и кодировки
Единственным надежным способом записать в поток `DataOutputStream` строку так, чтобы ее можно было потом правильно прочитать потоком `DataInputStream` является кодирование в *UTF-8*, реализуемое мотодом `readUTF()` и `writeUTF()`<br/>
Если работать только с кодировкой *ASCII* или основным подмножеством *ASCII*, "удвоение" данных приводит к неоправданным затратам пространства и нагрузке на сеть.<br/>
Поэтому *UTFF-8* кодирует символы *ASCII* одним байтом, а символы из других кодировок записывает двумя или тремя байтами. Кроме того, в первых двух байтах строки хранится ее длина.<br/>
Методы `readUtf()` и `writeUtf()` используют специальную модификацию *UTF для java* (она описана в документации JDK) и для правильного считывания из другой программы (_не_ Java) строки, записанной методом `writeUtf()`, придется добавить в нее специальный код, обеспечивающий ее правильное считывание.<br/>
Методы `readUtf()` и `writeUtf()` позволяют смешивать строки и другие типы данных, записываемые потоком `DataOutputStream`, так как известно, что строки будут правильно сохранены в Юникоде и их будет легко восстановить потоком `DataInputStream`<br/>
_Эккель Б. Философия Java. 4-е полное изд. Стр. 749_