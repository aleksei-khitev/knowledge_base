# Вопросы и задачи с собеседований, ассесментов
## Методологии разработки
### Waterfall Model
Одна из самых старых, подразумевает последовательное прохождение стадий, каждая из которых должна завершиться полностью до начала следующей. В модели Waterfall легко управлять проектом. Благодаря её жесткости, разработка проходит быстро, стоимость и срок заранее определены. Но это палка о двух концах. Каскадная модель будет давать отличный результат только в проектах с четко и заранее определенными требованиями и способами их реализации.<br/>
Нет возможности сделать шаг назад, тестирование начинается только после того, как разработка завершена или почти завершена. Продукты, разработанные по данной модели без обоснованного ее выбора, могут иметь недочеты (список требований нельзя скорректировать в любой момент), о которых становится известно лишь в конце из-за строгой последовательности действий. Стоимость внесения изменений высока, так как для ее инициализации приходится ждать завершения всего проекта.<br/>
**Преимущества**
* Разработку просто контролировать. Заказчик всегда знает, чем сейчас заняты программисты, может управлять сроками и стоимостью
* Стоимость проекта определяется на начальном этапе. Все шаги запланированы уже на этапе согласования договора, ПО пишется непрерывно «от и до».
* Не нужно нанимать тестировщиков с серьёзной технической подготовкой. Тестировщики смогут опираться на подробную техническую документацию.

**Недостатки**
* Тестирование начинается на последних этапах разработки. Если в требованиях к продукту была допущена ошибка, то исправить её будет стоить дорого. Тестировщики обнаружат её, когда разработчик уже написал код, а технические писатели — документацию.
* Заказчик видит готовый продукт в конце разработки и только тогда может дать обратную связь. Велика вероятность, что результат его не устроит.
* Разработчики пишут много технической документации, что задерживает работы. Чем обширнее документация у проекта, тем больше изменений нужно вносить и дольше их согласовывать.


**Когда использовать?**
* Только тогда, когда требования известны, понятны и зафиксированы. Противоречивых требований не имеется.
* Нет проблем с доступностью программистов нужной квалификации.
* В относительно небольших проектах.

### Rational Unified Process
Каждая итерация в RUP это классический Waterfall, содержащий все 5 этапов работ по сбору требований и их анализу, проектированию, разработке, тестированию и доставке. Но RUP также вводит такое понятие как фазы для проекта: Сбор требований и Анализ, Проектирование, Построение, Внедрение.
![](https://hsto.org/web/81f/d46/4f2/81fd464f27c2480c9ced103ff327164b.jpg)

* **Новация №1**, заложенная в её основу, это «Бизнес-моделирование» и связанные с ним Сценарии Использования (Use Case). Сперва разрабатывается бизнес-сценарий использования, где будущая система представляет собою «чёрный ящик», который удовлетворяет все потребности Пользователя/Бизнеса. На его основе разрабатываются системные сценарии использования, описывающие функции системы, которые будут поддерживать выполнение бизнес-сценария.
* **Новация №2**: На основе выделенных системных сценариев использования системы принимаются архитектурные решения и выделяются компоненты, которые будут поддерживать бизнес-сценарии и решается будут ли они использоваться совместно для поддержки нескольких бизнес-сценариев или останутся заточенными под конкретный сценарий. (Объектно-ориентированное проектирование и программирование)
* **Новация №3:** Наличие выделенных сценариев использования системы позволяет разделить их на первичные и вторичные. Вторичные основываются на результатах выполнения первичных сценариев, которые по большому счёту самодостаточны. Отсюда появляется возможность выделить итерации и разложить реализацию всех сценариев по ним.

**Схема итерации**
![Схема итерации](https://hsto.org/web/9be/c57/8b7/9bec578b7a464ca6b4e4c80aac1f566d.jpg)

### Agile
![](https://hsto.org/getpro/habr/post_images/e74/d98/4e0/e74d984e076ba5c32d33acae06341613.jpg)

### Scrum & Kanban
* Основу Scrum составляют короткие итерации или спринты, как правило, 2-3-х недельные. Перед началом спринта команда сама формирует список фич на итерацию, далее запускается спринт.
* После окончания спринта выполненные фичи заливаются на продакшн, а невыполненные — переносятся в другой спринт. Как правило, фичи, которые делаются во время спринта, не меняются: что было на старте спринта — должно быть сделано любой ценой к окончанию спринта.

Kanban дает больше гибкости, если под гибкостью понимать частоту смены приоритетов. Вчера вы залили на прод новую фичу, а сегодня получили данные с передовой и узнали, что вот эта штука не работает так, как было задумано — люди не нажимают кнопку «купить». Вы «даете по шапке» UX, он дает вам новые требования. Вы поднимаете наверх очереди эту задачу, программист берет эту задачу «сверху», выполняет ее и, к вечеру fix уже на проде, конверсия в платежи выросли на 12%. Это победа.

В Scrum задачи принято оценивать в Story points или в часах. Без оценки не получится сформировать спринт: ведь нам нужно знать, успеем ли мы сделать задачи за 2 недели. Через 2 недели мы получаем ценную статистику — сколько часов или Story points команда смогла сделать за спринт. Velocity — это производительность команды за один спринт. Этот параметр позволяет Scrum менеджеру предсказать, где команда будет через 2 недели.

В Kanban не принято делать оценку. Это опционально, команда решает сама. Здесь нет понятия «скорость работы команды», считается только среднее время на задачу. Время это считается с помощью специального отчета — Cycle Time.

Cycle Time для задачи = время выполнения задачи минус время начала работы над задачей. Например, у вас есть колонки: to do, reopened, developing, testing, stage testing, deployed. Cycle time для задачи будет равен deployed-developing, то есть сколько времени прошло от момента, когда задачу начали делать до момента пока она попала в deployed.

Итак, в Scrum наша цель — закончить спринт, в Kanban — задачу. 

#### Интересности в Kanban
Во-первых, это **WIP (Work in progress)**. Мы ставим ограничение на число задач, которые может одновременно делать один сотрудник.<br/>
**Swimlanes**. К примеру, _Blockers_.

## Continuous Integration, Continuous Delivery и Continuous Deployment
![](https://hsto.org/webt/dw/ml/9u/dwml9uvhrawfod4kvgxvblpuazy.jpeg)
* Непрерывная интеграция (CI): короткоживущие функциональные ветки, команда сливает их с основной веткой разработки по несколько раз в день, процессы сборки и тестирования полностью автоматизированы, результат имеем в пределах 10 минут; развертывание выполняется вручную.
* Непрерывная доставка (CD): автоматизируется CI + весь процесс релиза ПО. Может состоять из нескольких этапов. Развертывание в продакшен выполняется вручную.
* Непрерывное развертывание: CI + CD + полностью автоматизированное развертывание в продакшен.

## Ретроспектива версий java
### Java 9
* **Jigsaw**
* **Jshell**: Новый инструмент командной строки. Если разработчик хочет автономно запустить несколько строк Java, то это можно выполнить без необходимости заворачивать все в отдельный метод или проект.
* **Immutable List, Set, Map, и Map.Entry API**. Создание множеств из нескольких элементов в Java 8 требовало нескольких строк кода. Теперь это можно осуществить только одной. `List.of(...)`
* Полная поддержка клиента **HTTP 2.0** (на 11.81% до 47.7% быстрее HTTP 1.1)
* **java.util.concurrent.Flow**. Flow — это Java-реализация Reactive Streams API
* `InputStream.transferTo(OutputStream)`
* StackWalker
* **Unified JVM Logging**
* **Microbenchmark** is measuring the performance of some small code fragment.

### Java 10
* **Local-Variable Type Inference**. `var data = new ArrayList<String>();`
* `Reader.transferTo(Writer)`
* Дальнейшее рахвитие `StackWalker`
* Copy factory methods for unmodifiable List, Set, Map. `List.copyOf`, `Set.copyOf` и `Map.copyOf`
* Новые коллекторы в Stream API: toUnmodifiableList, toUnmodifiableSet и toUnmodifiableMap

### Java 11
* Изменение в String (`isBlank`)  и изменения во многих других классах
* Launch Single-File Source-Code Programs. `java HelloWorld.java`
* поддержка HTTP Client API стандартизирована
* Удалены модули Java EE и COBRA

### Java 12
* Microbenchmark Suite
* Switch Expressions. Для избежания `break`, предлагают так`
```java
switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);
    case TUESDAY                -> System.out.println(7);
    case THURSDAY, SATURDAY     -> System.out.println(8);
    case WEDNESDAY              -> System.out.println(9);
}
```
### Java 13
* **Text Blocks** Они позволяют избегать экранирования символов и умеют форматировать строки
```java
String htmlBlock = """
               	<html>
                 	<body>
                   	<p>CodeGym Web page</p>
                 	</body>
               	<html>
         	     """;
```

## Race condition
Пример. Есть `int x = 0`. Есть 2 потока с `x++`.<br/>
В итоге может быть `x==2`, а может `x==1` из-за Race condition

## Нефункциональные требования
* Функциональные требования - описывающие, что необходимо реализовать в продукте или системе, в т.ч. какие действия должны выполнять пользователи при взаимодействии с ними
* Нефункциональные требования - описывающие, как должна работать система или программный продукт, и какими свойствами или характеристиками она должна обладать

К нефункциональным требованиям относятся:
* атрибутах качества (т.е. требованиях, определяющих качественные характеристики разрабатываемого программного обеспечения или системы, такие как производительность, надежность, масштабируемость)
* Ограничения — условия, ограничивающие выбор возможных решений по реализации отдельных требований или их наборов («Разработка должна вестись на платформе вендора X», «При аутентификации пользователя должны использоваться биометрические методы идентификации»)
* Бизнес-правила - корпоративные политики, правительственные постановления, промышленные стандарты и вычислительные алгоритмы, которые используются при разработке продукта или системы либо непосредственно влияют на разработку. («Если оплата по счету не поступила в течение 15 дней, заказ считается отменённым»)
* Внешние интерфейсы — описание аспектов взаимодействия с другими системами и операционной средой. К ним относятся требования к API продукта или системы, а также требования к API других систем, с которыми осуществляется интеграция («Обеспечить запись в журнал операционной системы следующих событий: сообщения о запуске и остановке сервиса XX»)
* Юридические требования — требования к лицензированию, патентной чистоте, etc.
Предложения по реализации — предложения, оценивающие возможность использования определенных технологических и архитектурных решений.
Предложения по тестированию разрабатываемого ПО — дополнения к требованиям, указывающие, каким образом то или иное требование должно быть протестировано.

Что с ними делать?
* Собрать информацию (Составить шаблон, в котором нужно перечислить основные виды нефункциональных требований (по Виггерсу))
* Проанализировать
* Составить сецификацию

## Мотивация сотрудников
* Материальная мотивация персонала
* * Денежная мотивация персонала
* * * Заработная плата, в том числе её повышение
* * * Проценты от продаж
* * * Бонусы, премии, надбавки
* * * Страховки, социальные пакеты
* * * Вознаграждение победителя конкурса для персонала
* * Неденежная мотивация персонала
* * * Возможность пройти обучение за счет компании
* * * Возможность получать от компании путевки для сотрудников и членов его семьи
* * * Возможность бесплатного получения билетов в театр, цирк и другие культурные мероприятия
* * * Возможность пользоваться услугами партнеров компании с большими скидками, либо вообще бесплатно
* * Система штрафов
* * * Взыскание денег с работника компании за невыполнения нормативов и стандартов
* * * Взыскание денег с сотрудника за его плохую работу
* * * Дополнительные рабочие часы за плохую работу
* Нематериальная мотивация персонала
* * Повышение по службе. Как в горизонтальной, так и в вертикальной карьерной лестнице
* * Участие в совещаниях с руководством
* * Мотивационные совещания
* * Хорошая атмосфера в коллективе. Дружная сплоченная команда служит дополнительной мотивацией для эффективной производительности труда
* * Культурные и спортивные мероприятия внутри компании
* * Конкурсы и соревнования
* * Престиж предприятия
* * Публичное признание достижений сотрудника
* * Поздравления со значимыми датами для сотрудника
* * Оценки коллег
* * Помощь в семейных делах
* * индивидуальный график работы
* * прозрачная форма управления персоналом и взаимодействия с работниками

## SOLID
### Single Responsibility Principle
Существует лишь одна причина, приводящая к изменению класса.<br/>
Один класс должен решать только какую-то одну задачу. Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи. Все методы и свойства должны служить одной цели. Если класс имеет несколько назначений, его нужно разделить на отдельные классы
### Open-closed Principle
Программные сущности должны быть открыты для расширения, но закрыты для модификации.<br/>
Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого. Если строго соблюдать этот принцип, то можно регулировать поведение кода без изменения самого исходника.
### Liskov Substitution Principle
Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.
### Interface Segregation Principle
Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.<br/>
Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.
### Dependency Inversion Principle
Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.<br/>
Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.<br/>
Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.

## GRASP (General Responsibility Assignment Software Principles)
### Creator
Шаблон creator говорит нам какие условия должны соблюстись, что бы объекты верно порождали друг друга. Для этого есть несколько правил:
* объект А должен порождать объект Б, если:
* объект А содержит или агрегирует объекты Б (содержит в себе как свойство или коллекцию)
* объект А активно использует объекты Б (основной объем работы с объектом Б происходит посредством объекта А)
* объект А обладает данными инициализации объекта Б (каждый раз при создании объекта Б, данные берутся из объекта А)
### Information Expert
Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.
### Controller
Ну тут все просто. Это не что иное, как C из аббревиатуры MVC :) Этот шаблон отвечает за то, к кому именно должны обращаться вызовы из V (View), и кому C должен делегировать запросы на выполнение ( какая модель M должна их обработать )
### Low Coupling
Низкая связанность, отвечает за то, что бы объекты в системе знали друг о друге как можно меньше. Ведь чем меньше объект знает о других объектах, тем больше будет изолировано и тем меньше правок необходимо будет делать, если в системе что-то поменяется.
### High Cohesion
High Cohesion твердит, что класс должен стараться выполнять как можно меньше не специфичных для него задач, и иметь вполне определенную область применения
### Protected Variantions
сущность шаблона устойчивый к изменениям заключается в устранении точек неустойчивости, путем определения их в качестве интерфейсов и реализации для них различных вариантов поведения.
### Polymorphism
Шаблон полиморфизм позволяет обрабатывать альтернативные варианты поведения на основе типа. При этом, альтернативные реализации приводятся к обобщенному интерфейсу.
### Pure Fabrication
Существует понятие модели программирования по предметной области, согласно которой, каждой сущности из предметной области соответствует один или более классов программной среды. При этом, обязанности взаимодействия сущностей, как правило накладываются на них самих. Такой подход имеет очевидный недостаток — высокая связность модулей системы. Шаблон чистая выдумка позволяет решить данную проблему, путем введения в программную среду дополнительного класса (не отражающего реальной сущности из предметной области) и наделение его требуемыми обязанностями.
### Indirection
Шаблон перенаправление реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту — посреднику.

## F.I.R.S.T. Principles
* Быстрота (Fast)
* Независимость (Independent)
* Повторяемость (Repeatable)
* Очевидность (Self-Validating). Не нужно заставлять людей читать логи только для того, чтобы определить прошел тест успешно или нет.
* Своевременность (Timely). Тесты должны создаваться своевременно. Несвоевременность написания тестов является главной причиной того, что они откладываются на потом, а это “потом” так никогда и не наступает.

## Микросервисная архитектура: плюсы и минусы
Микросервисы - это путь разбиения большого приложения на слабо связанные модули, которые коммуницируют друг с другом посредством просто API.<br/>
В отличии от монолитных архитектурных приложений, микросервисы:
* Улучшает изоляцию сбоя компонентов: большие приложения можут продолжить эффективно работать, даже при неисправности какого-то отдельного модуля.
* Устраняет приверженность приложения к одному технологическому стеку: если хочешь попробовать новый технологический стек на каком-то сервисе - пожалуйста. Зависимости будут гораздло легче, чем при монолитном, к тому же будет намного проще откатить все вспять. Чем меньше кода в одном приложении, тем легче работать.
* Делает намного проще для новых сотрудников, чтобы понять функционаьность сервиса.

Микросервисы: недостатки
* Разработка распределенных систем может быть трудной. Под этим я подразумеваю, что все компоненты теперь независимые сервисы - нужно очень аккуратно обрабатывать запросы проходящие между модулями. Может быть сценарий, когда один модуль не отвечает, заставляя писать дополнительный код, чтобы избежать сбоя системы. Это может быть сложнее, если удаленные вызовы чувствительны к latency.
* Множество баз данных и управление транзакций может быть реальной болью
* тестирование микросервисных приложений может быть громоздко. Используя монолитное приложение, нам нужно только запустить WAR/EAR/JAR архив на сервер и убедиться в связи с базой данных. А в микросервисах, каждый отдельный сервис должен быть запущен перед тем, как начать тестирование.
* Монтирование приложений может быть сложным. Они могут требовать координации вокруг множества сервисов, которые могут быть не так просто монтироваться, как WAR контейнер.
## ACID
* atomicity (атомарность). никакая транзакция не будет зафиксирована в системе частично.
* consistency (согласованность). каждая успешная транзакция по определению фиксирует только допустимые результаты
* isolation (изолированность). Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
* durability (долговечность). если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. 

## Уровни изоляции
| Уровень изоляции | Описание |
| --- | --- |
| `ISOLATION_DEFAULT` | Стандартный уровень изоляции базового информационного хранилища |
| `ISOLATION_READ_UNCOMMITTED` |  Самый низкий, на котором транзакцию едва ли можно назвать таковой, поскольку на нем доступны данные, модифицированные в других незавершенных транзакциях |
| `ISOLATION_READ_COMMITTED` | Стандартны уровень изоляции в большинстве БД.<br/>На эом уровне гарантируется, что нельзя читать  данные, которые еще не зафиксированы в текущей транзакции. Но данные, прочитанные в одной транзакции могут быть обновлены в других. |
| `ISOLATION_REPEATABLE_READ` | Более строгий уровень, чем `ISOLATION_READ_COMMITTED`.<br/>На этом уровне гарантируется, что после выборки данных можно произвести повторную выборку, по крайней мере, того же самого набора данных.<br/>Если же новые данные были введены в других транзакциях, вновь введенные данные могут быть извлечены |
| `ISOLATION_SERIALIZABLE` | Самый дорогостоящий и надежный уровень.<br/>На этом уровне все транзакции трактуются как выполняемые последовательно одна за другой |
## Режим распространения
| Режим распространения | Описание |
| --- | --- |
| `PROPAGATION_REQUIRED` | Поддерживает транзакцию, если она уже существует.<br/>А если транзакция отсутствует, то начинается новая транзакция |
| `PROPAGATION_SUPPORTS` | Поддерживает транзакцию, если она уже существет.<br/>А если транзакция отсутствует,то выполнение осуществляется без транзакции |
| `PROPAGATION_MANDATORY` | Поддерживает транзакцию, если она уже существет<br/>А если активная транзакция отсутствует, то генерирует исключение |
| `PROPAGATION_REQUIRES_NEW` | Всегда начинает новую транзакцию.<br/>Если активная транзакция уже существет, она приостанавливается |
| `PROPAGATION_NOT_SUPPORTED` | Не поддерживает выполнение с активной транзакцией.<br/>Всегда выполняется без транзакций и приостанавливает любые существующие транзакции |
| `PROPAGATION_NEVER` | Всегда выполняется без транзакций, даже если имеется активная транзакция.<br/>Если же активная транзакция существет, генерируется исключение |
| `PROPAGATION_NESTED` | Выполняется во вложенной транзакции, если существет актинвая транзакция.<br/>А если транзакция отсутствует, то выполняется так, как будто установлено значение `PROPAGATION_REQUIRED` |

## CAP theorem, BASE
В любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:
* consistency — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;
* availability — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
* partition tolerance — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.
![](https://i.stack.imgur.com/RAOBl.png)
![](https://hsto.org/getpro/habr/post_images/5ea/6e0/5c6/5ea6e05c6e882b2c695570a487f7f1d0.gif)
CAP - это, по сути, континуум, по которому BASE и ACID находятся на противоположных концах<br/>
* ACID focuses on Consistency and availability.
* BASE focuses on Partition tolerance and availability and throws consistency out the window.

## Характеристики NoSQL баз данных
* Не используется SQL. многие базы пытаются использовать query languages похожие на общеизвестный любимый синтаксис, но полностью его реализовать не удалось никому и вряд ли удастся.
* Неструктурированные (schemaless). Смысл таков, что в NoSQL базах в отличие от реляционных структура данных не регламентирована (или слабо типизированна, если проводить аналогии с языками прогаммирования) — в отдельной строке или документе можно добавить произвольное поле без предварительного декларативного изменения структуры всей таблицы.
* Представление данных в виде агрегатов (aggregates). В отличие от реляционной модели, которая сохраняет логическую бизнес-сущность приложения в различные физические таблицы в целях нормализации, NoSQL хранилища оперируют с этими сущностями как с целостными объектами
* Слабые ACID свойства
* Распределенные системы, без совместно используемых ресурсов (share nothing). основные свойства распределенных NoSQL баз:
* * Репликация — копирование данных на другие узлы при обновлении.
* * Шардинг — разделение данных по узлам:
* NoSQL базы в-основном оупенсорсные и созданы в 21 столетии.

## Технические характеристики решений NewSQL
* SQL как основной механизм для взаимодействия. 
* ACID поддержка транзакций.
* Механизм управления без применения блокировок, таким образом считывающие данные в реальном времени не будут находится в противоречии с записывающими, что исключает конфликт
* Архитектура, обеспечивающая намного выше производительность узла, чем доступный из традиционных решений RDBMS.
* Удобное масштабирование, способное управлять большим количеством узлов, не перенося узкие места.

## Stream API
Stream API — это новый способ работать со структурами данных в функциональном стиле<br/>
Stream API поддерживает множество паралельных операций обработки данных и чем-то напоминает язык запросов БД. Не нужно  упрвлять многопоточностью самому
### Способы создания стримов
* `collection.stream()`
* `Stream.of(значение1,… значениеN)`
* `Arrays.stream(массив)`
* `Files.lines(путь_к_файлу)`
* `«строка».chars()`
* `Stream.builder().add(...)....build()`
* `collection.parallelStream()`
* `Stream.iterate(начальное_условие, выражение_генерации)`
### Конвейерные методы
* `filter`
* `skip` Позволяет пропустить N первых элементов
* `distinct`. Возвращает стрим без дубликатов (для метода equals)
* `map` Преобразует каждый элемент стрима
* `peek` Возвращает тот же стрим, но применяет функцию к каждому элементу стрима
* `limit` Позволяет ограничить выборку определенным количеством первых элементов
* `sorted` Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
* `mapToInt`, `mapToDouble`, `mapToLong` Аналог map, но возвращает числовой стрим 
* `flatMap`, `flatMapToInt`, `flatMapToDouble`, `flatMapToLong` Похоже на map, но может создавать из одного элемента несколько
### Терминальные методы
* `findFirst`, `findAny`
* `collect`, `toArray`
* `count`
* `anyMatch`, `noneMatch`, `allMatch`
* `min`, `max`
* `forEach`, `forEachOrdered`
* `reduce` Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат

### Дополнительные методы у числовых стримов
* `sum`
* `average`
* `mapToObj`

### Дополнительные методы связанные с паралельностью
* `isParallel`
* `parallel` Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
* `sequential` Вернуть последовательный стрим, если стрим уже последовательный, то может вернуть самого себя

## Pessimistic and  optimistic locking
### Optimistic Locking
In order to use optimistic locking, we need to have an entity including a property with `@Version` annotation. While using it, each transaction that reads data holds the value of the version property.<br/>
Before the transaction wants to make an update, it checks the version property again.<br/>
If the value has changed in the meantime an `OptimisticLockException` is thrown. Otherwise, the transaction commits the update and increments a value version property. 
```java
@Version
@Column(name = "version")
public int getVersion() {
     return version;
}
```
### Pessimistic Locking
JPA specification defines three pessimistic lock modes which we're going to discuss:
* PESSIMISTIC_READ – allows us to obtain a shared lock and prevent the data from being updated or deleted
* PESSIMISTIC_WRITE – allows us to obtain an exclusive lock and prevent the data from being read, updated or deleted
* PESSIMISTIC_FORCE_INCREMENT – works like PESSIMISTIC_WRITE and it additionally increments a version attribute of a versioned entity
```java
entityManager.find(Student.class, studentId, LockModeType.PESSIMISTIC_READ);
```
```java
Query query = entityManager.createQuery("from Student where studentId = :studentId");
query.setParameter("studentId", studentId);
query.setLockMode(LockModeType.PESSIMISTIC_WRITE);
query.getResultList()
```
## BeanFactory
В этом примере используется DefaultListableBeanFactory в качестве одной из двух основных реализаций интерфейса BeanFactory, предоставляемых в Spring, а данные типа BeanDefinition читаются из XML средствами класса XmlBeanDefinitionReader
```java
    public static void main(String[] args) {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(factory);
        beanDefinitionReader.loadBeanDefinitions(new ClassPathResource(XML_CONFIG));
        BountyHunter bountyHunter = factory.getBean("Boba Fet", BountyHunter.class);
        System.out.println(bountyHunter.status());
    }
```

## BeanDefinition
```
Generic bean:
class [ru.akhitev.kb.spring.bean_factory_example.BobaFet];
scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0;
autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null;
initMethodName=null; destroyMethodName=null;
defined in class path resource [spring/bean_factory_example/bean-factory-example-cfg.xml]
```

## ApplicationContext
Интерфейс ApplicationContext расширяет интерфейс BeanFactory, дополнительно к внедрению зависимостей включает:
* транзакции
* АОП
* интернационализация
* публикация и обработка событий в приложениях
* доступ к ресурсам и управление ими
* дополнительные интерфейсы жизненного цикла
* улучшенное автоматическое конфигурирование компонентов инфраструктуры

## component-scan и ComponentScan
```xml
    <context:component-scan
            base-package="ru.akhitev.kb.spring.component_scan_xml_example.ships">
        <context:exclude-filter type="assignable"
                                expression="ru.akhitev.kb.spring.component_scan_xml_example.ships.Victory"/>
    </context:component-scan>
```
```java
@Configuration
@ComponentScan(basePackages = "ru.akhitev.kb.spring.component_scan_xml_example.ships",
        excludeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = Victory.class) })
public class MobileGroupJavaConfig {
```
## Сочетание конфигураций на Java и в XML
```java
@Configuration
@ImportResource("spring/java_config_example/beans.xml")
public class MapConfig {
    ...
}
```
`@Import` если другой класс
## Вложение одного контекста 
```java
GenericXmlApplicationContext childContext = new GenericXmlApplicationContext();
childContext.load("spring/parent_context/child.xml");
childContext.setParent(parentContext);
childContext.refresh();
```
## задать имя Spring Bean
`@Component("Agamemnon")`, в `@Bean`, можно воспользоватьс атрибутом `name`
## depends-on, @DependsOn
`depends-on="someBean"`, `@DependsOn("someBean")`<br/>
В том случае, если в одном компоненте может быть получен другой компонент без автосвязывания, а через context.getBean(...), получаемый компонент может быть не готов
## Режимы втосвязывания
`<bean id="unitByName" autowire="byName"`

* **byName** - Spring пытается связать каждое свойство с одноименным компонентом Spring bean
* **byType** - Spring пытаетсясвязатькаждое свойство целевого компонента Spring Bean с компонентом того же самого типа
* **constructor** - действует, как `byType`, за исключением того, что зависимости внедряются в нем через конструкторы, а не методы установки. Spring пытается обнаружить совпадение с как можно большим числом аргументов в конструкторе. Так, если у компонента Spring Bean имеются 2 конструктора, причем первый из принимает `String`, а второй - `String` и `Integer`, а в контексте есть компоненты Spring Bean типа `String` и `Integer`, то Spring использует конструктор с двумя аргументами
* **default** - Spring автоматически делает выбор между `constructor` и `byType`. Если у компонента Spring Bean есть конструктор по умолчанию (без аргументов), то Spring выберет `byType`, а иначе - `constructor`
* **no** - выбирается по умолчанию
## Атрибут primary
```xml
<bean id="Agamemnon" class="ru.akhitev.kb.spring.primary.OmegaDestroyer" primary="true" />
<bean id="Agrippa" class="ru.akhitev.kb.spring.primary.OmegaDestroyer" />
```
```java
@Component
@Primary
public class Agamemnon implements OmegaDestroyer  {}
```
## Qualifier для выбора одного из компонентов
```java
@Component
@Primary
public class Agamemnon implements OmegaDestroyer {}
@Component
public class Agrippa implements OmegaDestroyer {}
@Component
public class PatrolMission {
    @Autowired
    @Qualifier("agrippa")
    private OmegaDestroyer destroyer;
```
## @Value
С помощью аннотации @Value можно определить внедряемое значение.<br/>
Помимо внедрения простых символьных строк, можно воспользоваться языком SpEL
```java
    public MessageBeam(@Value("#{message}") String message) {
        this.message = message;
    }
```
## @Autowired только в одном конструкторе!
## Коллекции
```xml
<map><entry key="Nebulon-B 2"><value>6</value></entry>...</map>
<set><value>Зоркий</value>...</set>
<util:map id="scoutLineShips"
map-class="java.util.HashMap" key-type="java.lang.String" value-type="java.lang.Integer"><entry key="Nebulon-B 2" value="6" />...</util:map>
```
```java
    @Resource(name = "scoutLineShips")
    private Map<String, Integer> ships;
```
## Основная причина внедрения через метод поиска
Внедрение зависимостей через метод поиска позволяет объявить в singleton'е, что ему требуется неодиночная зависимость и что он будет получать новый экземпляр неодиночного компонента Spring Beans всякий раз, когда ему приходится взаимодействовать с ним, не прибегая к реализации любого характерного для Spring интерфейса
```xml
    <bean id="correctTurboLaser" class="ru.akhitev.kb.spring.lookup_method.CorrectTurboLaserTurret">
        <lookup-method name="getNewShellBelt" bean="shellBelt" />
    </bean>
```
```java
@Component
public abstract class CorrectTL50 implements MachineGun {
    @Lookup
    public abstract MachineGunBelt getNewShellBelt();
...}
```
## Проведение замены. MethodReplacer
```xml
<bean id="jediTempleMessageBeaconReplacer"
      class="ru.akhitev.kb.spring.replace_method.UpdatedByKenobiMessageBeacon"/>
<bean id="replacementTarget"
      class="ru.akhitev.kb.spring.replace_method.JediTempleMessageBeacon">
    <replaced-method name="getMessage" replacer="jediTempleMessageBeaconReplacer"/>
</bean>
```
```java
public class UpdatedByKenobiMessageBeacon implements MethodReplacer {
    @Override
    public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
        ...
    }
...
}
```
## life cycle
![](https://raw.githubusercontent.com/aleksei-khitev/knowledge_base/master/spring-bean-lifecycle.png)
Помимо `init-method` может быть `default-init-method`<br/>
В java `@Bean(initMethod = "init")`

## Уничтожение компонентов
через `context.getDefaultListableBeanFactory().destroySingletons();`<br/>
он же вызывается при `AbstractApplicationContext.close();`<br/>
Чтобы не вызывать явно, `AbstractApplicationContext.registerShutdownHook();`
так вызовутся `destroy-method`-ы. в java `@Bean(initMethod = "init", destroyMethod = "deconstruct")`

## ...Aware
```java
public class User implements BeanNameAware {
    @Override public void setBeanName(String name) {...}
```
```java
public class RobotCleanerLauncher implements ApplicationContextAware {
    @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {...}
```

## Фабрики
```java
public class KuatShipYard implements FactoryBean<ISD> {
    @Override public ISD getObject() throws Exception { return new ISD();}
    @Override public Class<?> getObjectType() { return ISD.class; }
}
```
```xml
<bean id="reinforcement" c:isd-ref="kuatShipYard"
      class="ru.akhitev.kb.spring.life_cycle.factory_bean.Reinforcement" />
```
Чтоб получить не объект, а саму фабрику, `context.getBean("&kuatShipYard")`
## Атрибуты factory-bean и factory-method
Иногда требуется получить экземпляры компонентов Java Bean, предоставляемых сторонним приложением, не поддерживающим Spring.
## PropertyEditor
```java
public class CraftSummaryPropertyEditor extends PropertyEditorSupport {
    @Override
    public void setAsText(String text) throws IllegalArgumentException {...}
}
```
```xml
<bean name="customEditorConfigurer"
      class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
        <map>
            <entry key="ru.akhitev.kb.spring.propert_editor.CraftSummary"
                   value="ru.akhitev.kb.spring.propert_editor.CraftSummaryPropertyEditor"/>
        </map>
    </property>
</bean>

<bean id="character" class="ru.akhitev.kb.spring.propert_editor.Character" c:_0="Эндемеон">
    <constructor-arg><list>
            <value>р_т6к6</value>
        </list></constructor-arg>
</bean>
```
## MessageSource
```xml
<bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource"
      p:basenames-ref="basenames" />

<util:list id="basenames">
    <value>ships</value>
    <value>messages</value>
</util:list>
```
```
# В messages_en.properties
departure={0} has departed to {1}
```
```java
System.out.println(context.getMessage("arrived", new Object[]{"Devastator"}, english));
```
## Event'ы
```java
public class Player implements ApplicationListener<BattleGroundEvent> {
    @Override
    public void onApplicationEvent(BattleGroundEvent event) {...}
}
```
```java
public class BattleGround implements ApplicationContextAware {
    public void fight() {...
        context.publishEvent(new BattleGroundEvent(this, BattleGroundEvent.Type.STOP));
    ...}
}
```
## Profiles
```xml
<beans ...
       profile="ВКО" >
```
```java
@Configuration
@Profile("archeAge")
public class ArcheAge {
```
Активация<br/>
передав аргумент `-Dspring.profiles.active="archeAge"` в VM optons.
```java
context.getEnvironment().setActiveProfiles("lotro");
context.load("spring/profiles/*.xml");
context.refresh();
```
## @PropertySource, property-placeholder, Environment
```xml
<context:property-placeholder
    location="spring/environment_properties_injection/infrastructure.properties" />
```
```java
@Configuration
@PropertySources({
        @PropertySource("classpath:spring/environment_properties_injection/infrastructure.properties"),
        @PropertySource("classpath:spring/environment_properties_injection/user.properties")
})
public class Launcher {
```
Получение через `context.getEnvironment().getProperty("transmission.address")`<br/>
или `@Value("${transmission.address}"`
## Groovy conf
```groovy
beans {
    endemeon(Player, name: "Endemeon", level: 170)
    emeon(Player, name: "Emeon", level: 45)
    myCharacters(Roster, players: [endemeon, emeon])
}
```
## понятия АОП
* **advice** Фрагмнт кода, который должен выполняться в отдельной точке соединения
* **pointcut** Совокупность точек соединения, предназначенная для определения момента, когда следует выполнить совет
* **aspect** Сочетания совета и срезов, инкапсулированных в классе
## Ограничение на объекты для АОП
Для реализации АОП в Spring невозможно снабдить советом оконченые классы, поскольку они не могут быть расширены, а следовательно, их нельзя заместить. Оконченый класс нельзя заместить и в том случае, есои он не реализует интерфейс
## Две реализации в Spring
* По умолчанию, если целевой объект, снабженный советом, реализует какой-нибудь интерфейс, для получения экземпляров заместителей целевого объекта в Spring будет использован динамический заместитель JDK.
* Но если целевой объект, снабженный советом, не реализует интерфейс, то для получения экземпляров заместителей будет применяться библиотека CGLIB
## jdbctemplate и свой ExceptionTranslator
```java
public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {
    @Override
    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {...}
}
```
```java
jdbcTemplate.setExceptionTranslator(mySQLErrorCodesTranslator);
```
## jdbc. после вставки получить ID
в `preparedStatement()` второй параметр `Statement.RETURN_GENERATED_KEYS`. Получить у `statement` сгенерированные ID через `statement.getGeneratedKeys()`
```java
Class.forName("com.mysql.cj.jdbc.Driver");
connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/fleet?useSSL=true",
                "commander", "commander_123");
PreparedStatement statement =
        connection.prepareStatement("insert into fleet_unit(name) values(?)",
                Statement.RETURN_GENERATED_KEYS);
statement.setString(1, fleetUnit.getName());
statement.execute();

ResultSet generatedKeys = statement.getGeneratedKeys();
if (generatedKeys.next()) {
    fleetUnit.setId(generatedKeys.getLong(1));
}
statement.close();
```
## DataSource и Connection
`DataSource` предоставляет реализации `Connection` и управляет ими.
```xml
<bean name="dataSource"
      p:driverClassName="${jdbc.driverClassName}"
      p:url="${jdbc.url}"
      p:username="${jdbc.user_name}"
      p:password="${jdbc.password}"
      class="org.springframework.jdbc.datasource.DriverManagerDataSource">
</bean>
```
```java
    @Bean
    @Lazy
    public DataSource dataSource() {
        try {
            SimpleDriverDataSource dataSource
                    = new SimpleDriverDataSource();
            Class<? extends Driver> driver = (Class<? extends Driver>) Class.forName(driverClassName);
            dataSource.setDriverClass(driver);
            dataSource.setUrl(url);
            dataSource.setUsername(userName);
            dataSource.setPassword(password);
            return dataSource;
        } catch (ClassNotFoundException e) {
            logger.error("", e);
            return null;
        }
    }
```
```java
connection = dataSource.getConnection();
```
## JdbcTemplate
```java
jdbcTemplate = new JdbcTemplate();
jdbcTemplate.setDataSource(dataSource);
jdbcTemplate.queryForObject("select name from fleet_unit where id = ?",
                objects,
                String.class);
```
## NamedParameterJdbcTemplate
```java
new NamedParameterJdbcTemplate(dataSource());
Map<String, Object> parameters = new HashMap<>();
        parameters.put("id", id);
        return namedParameterJdbcTemplate.queryForObject("select name from ship where id = :id",
                parameters,
                String.class);
```
## RowMapper
```java
public class ShipDao {
    ...
    public List<Ship> findAll() {
        return namedParameterJdbcTemplate.query("select * from ship", new ShipRowMapper());
    }
    ...
    private static final class ShipRowMapper implements RowMapper<Ship> {

        @Override
        public Ship mapRow(ResultSet rs, int rowNum) throws SQLException {
            Ship ship = new Ship();...
            return ship;
        }
    }
}
```
## ResultSetExtractor
```java
public class FleetUnitDao implements InitializingBean {
    ...
    public List<FleetUnit> findAllWithShips() {
        return jdbcTemplate.query("select f.id as f_id, f.name as fleet_unit_name, " +
                "s.id as ship_id, s.name as ship_name, s.fleet_unit_id, s.type, s.ship_class " +
                "from fleet_unit f " +
                "left join ship s on f.id = s.fleet_unit_id", new FLeetUnitResultSetExtractor());
    }
    ...
    public static final class FLeetUnitResultSetExtractor implements ResultSetExtractor<List<FleetUnit>> {

        @Override
        public List<FleetUnit> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<Long, FleetUnit> map = new HashMap<>();
            FleetUnit fleetUnit = null;
            while (rs.next()) {
                Long id = rs.getLong("f_id");
                fleetUnit = map.get(id);
                if (fleetUnit == null) {
                    fleetUnit = new FleetUnit();
                    fleetUnit.setId(id);...
                    map.put(id, fleetUnit);
                }
                long shipId = rs.getLong("ship_id");
                if (shipId > 0) {
                    Ship ship = new Ship();
                    ship.setId(shipId);...
                }
            }
            return new ArrayList<>(map.values());
        }
    }
}
```
## @Repository
@Repository - одна из разновидносте @Component, предназначенная для определения компонентов Spring Bean, выполняющих операции над БД.
Эта аннотация указыват на то, что снабженный ею класс представляет собой информационное хранилище, первоначально определенное как "механизм инкапсуляции поведения при сохранении, извлечении и поиске информации, эмулирующий коллекцию объектов", как поясняется в книге Domain-Driven Design Эрика Эванса.
Аннотация @Repository предписывает Spring преобразовывать исключения, возникающие при обработке запросов SQL в более удобную для приложения иерархию исключений DataAccessException, поддерживаемую в Spring
## MappingSqlQuery
```java
public class SelectAllFleetUnits extends MappingSqlQuery<FleetUnit> {
    private static final String QUERY = "select * from fleet_unit";

    public SelectAllFleetUnits(DataSource dataSource) {
        super(dataSource, QUERY);
    }

    @Override
    protected FleetUnit mapRow(ResultSet rs, int rowNum) throws SQLException {
        FleetUnit fleetUnit = new FleetUnit();...
        return fleetUnit;
    }
}
...
@Repository
public class FleetUnitDao implements InitializingBean {...
    public List<FleetUnit> findAll() {
        return selectAllFleetUnits.execute();
    }...
}
```
## MappingSqlQuery с параметром
```java
public class SelectFleetUnitNameById extends MappingSqlQuery<String> {
    private static final String QUERY = "select name from fleet_unit where id = :id";

    public SelectFleetUnitNameById(DataSource dataSource) {
        super(dataSource, QUERY);
        super.declareParameter(new SqlParameter("id", Types.INTEGER));
    }

    @Override
    protected String mapRow(ResultSet rs, int rowNum) throws SQLException {... }
}
...
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("id", id);
        List<String> names = selectFleetUnitNameById.executeByNamedParam(parameters);
```
## SqlUpdate
```java
public class UpdateFleetUnits extends SqlUpdate {
    private static final String QUERY = "update fleet_unit set name=:new_name where id=:id";

    public UpdateFleetUnits(DataSource dataSource) {
        super(dataSource, QUERY);
        super.declareParameter(new SqlParameter("id", INTEGER));
        super.declareParameter(new SqlParameter("new_name", VARCHAR));
        compile();
    }
}
...
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("id", id);
        parameters.put("new_name", newName);
        updateFleetUnits.updateByNamedParam(parameters);
```
## Извлечение сгенерированного ключа
```java
public class InsertFleetUnit extends SqlUpdate {
    private static final String QUERY = "insert into fleet_unit(name) values(:name);";

    public InsertFleetUnit(DataSource dataSource) {
        super(dataSource, QUERY);
        super.declareParameter(new SqlParameter("name", VARCHAR));
        super.setGeneratedKeysColumnNames("id");
        super.setReturnGeneratedKeys(true);
    }
}
...
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", fleetUnit.getName());
        KeyHolder keyHolder = new GeneratedKeyHolder();
        insertFleetUnit.updateByNamedParam(parameters, keyHolder);
        fleetUnit.setId(keyHolder.getKey().longValue());
```
## Hibernate SessionFactory
```xml
<util:properties id="hibernateProperties">
    <prop key="hibernate.dialect">org.hibernate.dialect.H2Dialect</prop>
    <prop key="hibernate.max_fetch_depth">3</prop>
    <prop key="hibernate.jdbc.fetch_size">50</prop>
    <prop key="hibernate.jdbc.batch_size">10</prop>
    <prop key="hibernate.hbm2ddl.auto">update</prop>
    <prop key="hibernate.use_sql_comments">true</prop>
    <prop key="hibernate.show_sql">true</prop>
    <prop key="hibernate.format_sql">true</prop>
    <prop key="hibernate.use_sql_comments">true</prop>
</util:properties>

<bean id="sessionFactory"
      p:dataSource-ref="dataSource"
      p:packagesToScan="ru.akhitev.kb.spring.hibernate.entity"
      p:hibernateProperties-ref="hibernateProperties"
      class="org.springframework.orm.hibernate5.LocalSessionFactoryBean" />

<bean id="transactionManager"
      p:sessionFactory-ref="sessionFactory"
      class="org.springframework.orm.hibernate5.HibernateTransactionManager" />
```
## Автогенерация таблиц БД
Свйосвто `hibernate.hbm2ddl.auto`
## Entity
```java
@Entity
@Table(name = "command_rank")
public class CommandRank {
    private Long id;
    private String name;
    private int version;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    public Long getId() {
        return id;
    }

    @Column(name = "name")
    public String getName() {
        return name;
    }

    @Version
    @Column(name = "version")
    public int getVersion() {
        return version;
    }
}
```
## Один ко многим
```java
@Entity
@Table(name = "command_rank")
public class CommandRank {
    ...
    @OneToMany(mappedBy = "commandRank",
            cascade = CascadeType.ALL,
            orphanRemoval = true,
            fetch = FetchType.EAGER)
    public List<FleetUnit> getFleetUnitsToCommand() {
        return fleetUnitsToCommand;
    }
    ...
}
...
@Entity
@Table(name = "fleet_unit")
public class FleetUnit {
    ...
    @ManyToOne
    @JoinColumn(name = "minimum_command_rank_id")
    public CommandRank getCommandRank() {
        return commandRank;
    }
    ...
}
```
## Многие ко многим
```java
@Entity
@Table(name = "fleet_unit")
public class FleetUnit {
    ...
    @ManyToMany
    @JoinTable(name = "fleet_unit_ship",
            joinColumns = @JoinColumn(name = "fleet_unit_id"),
            inverseJoinColumns = @JoinColumn(name = "ship_id"))
    public List<Ship> getShips() {
        return ships;
    }
    ...
}
```
## @EmbeddedId
```java
@Embeddable
public class FleetUnitShipEmbeddedId implements Serializable {
    private FleetUnit fleetUnit;
    private Ship ship;

    @ManyToOne
    @JoinColumn(name = "fleet_unit_id", insertable = false, updatable = false)
    public FleetUnit getFleetUnit() {
        return fleetUnit;
    }

    @ManyToOne
    @JoinColumn(name = "ship_id", insertable = false, updatable = false)
    public Ship getShip() {
        return ship;
    }

    //setters
}
...
@Entity
@Table(name = "fleet_unit_ship")
public class FleetUnitShipDetails {
    private FleetUnitShipEmbeddedId id;
    private Integer count;

    @EmbeddedId
    public FleetUnitShipEmbeddedId getId() {
        return id;
    }

    @Column(name = "ship_count")
    public Integer getCount() {
        return count;
    }
...
}
```
## createQuery
`sessionFactory.getCurrentSession().createQuery("from CommandRank cr").list();`
## NamedQuery
```java
@Entity
@Table(name = "fleet_unit")
@NamedQueries({
        @NamedQuery(name="FleetUnit.findAllWithShips",
            query = "select distinct fu from FleetUnit fu " +
                    "left join fetch fu.ships s " +
                    "left join fetch fu.commandRank")
})
public class FleetUnit {
```
`return sessionFactory.getCurrentSession().getNamedQuery("FleetUnit.findAllWithShips").list();`
## @NamedQuery с параметром
```java
        @NamedQuery(name = "FleetUnit.findAllWithShipsById",
             query = "select distinct fu from FleetUnit fu " +
                     "left join fetch fu.ships s " +
                     "left join fetch fu.commandRank " +
                     "where fu.id = :id")
```
```java
    return (FleetUnit) sessionFactory.getCurrentSession()
            .getNamedQuery("FleetUnit.findAllWithShipsById")
            .setParameter("id", id)
            .uniqueResult();
```
## Вставка
`sessionFactory.getCurrentSession().saveOrUpdate(commandRank);`
## JPA EntityManagerFactory
```java
    @Bean
    public EntityManagerFactory entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean entityManagerFactory =
                new LocalContainerEntityManagerFactoryBean();
        entityManagerFactory.setPackagesToScan("ru.akhitev.kb.spring.jpa.entity");
        entityManagerFactory.setDataSource(dataSource());
        entityManagerFactory.setJpaVendorAdapter(jpaVendorAdapter());
        entityManagerFactory.setJpaProperties(hibernateProperties());
        entityManagerFactory.afterPropertiesSet();
        return entityManagerFactory.getNativeEntityManagerFactory();
    }
```
## Получение EntityManager
```java
@Service
@Repository
@Transactional
public class FleetUnitService {
    @PersistenceContext
    private EntityManager entityManager;
```
## EntityManager.createNativeQuery
```java
        return entityManager
                .createNativeQuery(ALL_FLEET_UNIT_NATIVE_QUERY, FleetUnit.class)
                .getResultList();
```
## Запрос нетипизированных результатов
```java
@Transactional(readOnly = true)
public void displayFleetUnitAndCommandRank() {
    List result = entityManager
            .createQuery("select fu.name, fu.commandRank.name from FleetUnit fu ")
            .getResultList();
    for (Iterator i = result.iterator(); i.hasNext(); ) {
        Object[] values = (Object[]) i.next();
        logger.info(values[0] + ": " + values[1]);
    }
}
```
## Вставка и обновление
```java
public FleetUnit save(FleetUnit fleetUnit) {
    if (fleetUnit.getId() == null) {
        entityManager.persist(fleetUnit);
    } else {
        entityManager.merge(fleetUnit);
    }
    return fleetUnit;
}
```
## Удаление
```java
public void delete(Ship ship) {
    Ship mergedShip = entityManager.merge(ship);
    entityManager.remove(mergedShip);
}
```
## Criteria API и IN
```java
@Transactional(readOnly = true)
public List<FleetUnit> findByFewNames(String... names) {
    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
    CriteriaQuery<FleetUnit> criteriaQuery = criteriaBuilder.createQuery(FleetUnit.class);
    Root<FleetUnit> fleetUnitRoot = criteriaQuery.from(FleetUnit.class);
    CriteriaBuilder.In<String> inClause = criteriaBuilder.in(fleetUnitRoot.get("name"));
    for (String name : names) {
        inClause.value(name);
    }
    CriteriaQuery<FleetUnit> query = criteriaQuery.select(fleetUnitRoot).where(inClause);
    return entityManager.createQuery(query).getResultList();
}
```
## Аудит изменений
```java
@EntityListeners(AuditingEntityListener.class)
public class FleetUnit {
    ...
    @CreatedBy
    @Column(name = "created_by")
    private String createdBy;

    @CreatedDate
    @Column(name = "created_date")
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    @LastModifiedBy
    @Column(name = "last_modified_by")
    private String lastModifiedBy;

    @CreatedDate
    @Column(name = "last_modified_date")
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
```
```java
@Component
public class AuditorAwareBean implements AuditorAware<String> {
    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of("someUserName");
    }
}
```
```java
@EnableJpaAuditing(auditorAwareRef = "auditorAwareBean")
public class AppConfig {
```
## Аудит к нескольким сущностям
```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableEntity<U> implements Serializable {
    @CreatedBy
    @Column(name = "created_by")
    private String createdBy;

    @CreatedDate
    @Column(name = "created_date")
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    @LastModifiedBy
    @Column(name = "last_modified_by")
    private String lastModifiedBy;

    @CreatedDate
    @Column(name = "last_modified_date")
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
```
```java
@Entity
@Table(name = "ship")
public class Ship extends AuditableEntity<Ship> {
    ...
}
```
## Hibernate Envers
```sql
CREATE TABLE ship_h (
 id INT NOT NULL AUTO_INCREMENT,
 type VARCHAR(50) NOT NULL,
 ship_class VARCHAR(50) NOT NULL,
 link VARCHAR(200) NOT NULL,
 version INT NOT NULL DEFAULT 0,
 audit_revision INT NOT NULL,
 action_type INT,
 audit_revision_end INT,
 audit_revision_end_ts TIMESTAMP,
 UNIQUE uq_ship_h_1 (type, ship_class),
 PRIMARY KEY(id)
);
```
```java
    private Properties hibernateProperties() {
        ...
        properties.put("org.hibernate.envers.audit_table_suffix", "_H");
        properties.put("org.hibernate.envers.revision_field_name", "AUDIT_REVISION");
        properties.put("org.hibernate.envers.revision_type_field_name", "ACTION_TYPE");
        properties.put("org.hibernate.envers.audit_strategy", "org.hibernate.envers.strategy.ValidityAuditStrategy");
        properties.put("org.hibernate.envers.audit_strategy_validity_end_rev_field_name", "AUDIT_REVISION_END");
        properties.put("org.hibernate.envers.audit_strategy_validity_store_revend_timestamp", "True");
        properties.put("org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name",
                "AUDIT_REVISION_END_TS");
        ...
    }
```
## ForkJoinFramework
Инфраструктура Fork/Join Framework улучшает многопоточное программирование двумя способами:
* упрощает создание и использование нескольких потоков
* автоматизирует использование нескольких процессоров (при использовании Fork/Join Framework приложениям позволяется автоматически масштабировать количество доступных процессоров)

`RecursieAction`, `RecursiveTask<V>`<br/>
ForkJoinPool управляет выполнением своих потоков, используя поток захвата задачи (work-stealing).
Каждый рабочий поток поддерживает очередь задач. Если очередь одного потока оказывается пустой, то она возьмет задачу от другого потока. Это способствует повышению производительности и помогает поддерживать баланс нагрузки.<br/>
Как правило Fork / Join Framework применяет стратегию "разделяй и властвуй"., лежащую в основе рекурсии.<br/>
Стратегия "разделяй и властвуй" подразумевает разделение адач на подзадачи, пока их размер не станет достаточно маленьким для последовательной обработки.<br/>
```java
class CrowdToRaidGroupsTask extends RecursiveTask<Integer> implements GroupToRaidDivider {...
    @Override
    protected Integer compute() {
        if (underRaidGroupMateLimit(crowd)) {
            ...
        } else {
            ...
            // Запуск подзадач ветвления
            firstPartTask.fork();
            secondPartTask.fork();

            // Ожидание заверения и получение результата
            Integer firstPartGroupsNumber = firstPartTask.join();
            Integer secondPartGroupsNumber = secondPartTask.join();
            return firstPartGroupsNumber + secondPartGroupsNumber;
        }
    }...
}
```
## CompletableFuture
### Отличие get() и join()
```java
public class CompletableFuture<T> implements Future<T>, CompletionStage<T> {
    ...
    public T get() throws InterruptedException, ExecutionException {...}
    ...
    /** ...
     * @throws CompletionException if this future completed
     * exceptionally or a completion computation threw an exception
     */
    public T join() {...}
    ...
}
```
### Отмена выполнения
```java
lineFromTooSlowSource.cancel(true);
        lineFromTooSlowSource.join();
```
### runAsync(...) и supplyAsync(...)
Методы runAsync(...) полезны, если возвращать ничего не нужно<br/>
Методы supplyAsync(...) возвращают объект, получая его от заданного поставщика Supplier<br/>
### thenRun(), thenApply(), thenAccept(), thenCompose(), thenCombine()
* thenRun(...), когда нет ничего на входи и на выходе
* thenApply(...), когда ожидается какой то возврат
* theAccept(...), когда есть что то на входе, но нет на выходе
* thenCompose(). Аргументом для thenCompose() является функция, которая принимает результат первого объекта Future и преобразует его в выход для второго.
* thenCombine(). Метод thenCombine() принимает Future и BiFunction, причем результаты обоих Future доступны в функции, выислящей результат.
### allOf(), anyOf()
### Обработка исключений
```java
CompletableFuture<Integer> future = CompletableFuture
        .supplyAsync(() -> {
            throw new RuntimeException("error in async running");
        }).handle((obj, err) -> {
            System.out.print(err.getMessage());
            return 10;
        });
```
circuit breaer
ByteBuffer в nio

## Сложности алгоритмов
![](https://camo.githubusercontent.com/70e21c78e4d641614e704c74846912cfab42b718/68747470733a2f2f6873746f2e6f72672f66696c65732f3336342f6437652f3431392f33363464376534313930376534353362386536303132386364616334353964632e706e67)

## На что обратить внимание при ревью/рефакторинге задачи
* Как инжектированы bean-ы и как создаются объекты
* Нет ли возможных NPE, проверить Optional
* Не хранятся ли деньги во float или double
* Нет ли проблем в if/switch
* Нет ли проблем в try/catch
* Нельзя ли что-нибудь вынести в отдельный метод
* Нет ли проблем в транзакциях (api внутри @Transactional без отката или еще что нибудь))
* Можно ли что-нибудь закешировать

## ArrayList быстрее (в частности в переборе), чем LinkedList
`ArrayList` хранит данные в непрерывном куске памяти. `LinkedList` же выделяет память для каждого узла и связывает их ссылками

## Почему String сделали неизменяемым
Ради безопасности:
* можно передавать между потоками и не беспокоится, что будет изменена
* можно кэшировать хэш-код

String pool позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки

## Особенность `values()` у перечислений
Если сделать так `Enum someShip = Ship.DREADNOUGHT;`, то у `someShip` не будет метода `values()`
Так происходит, потому что `values()` является статическим методом, который вставлется в определение перечисления компилятором.

## Сколько места занимает ссылка в Java
4 байта или 8 байт в 64 разрядных

## synthetic
Конструкции, сделанные компилятором, которых не было в исходном коде.<br/>
Пример - Ссылка на верхне уровневый класс во вложенном классе

## LambdaMetafactory
был представлен в Java 8. Это дальнейшее развитие идеи динамического вызова.<br/>
позволяет нам генерировать экземпляр функционального интерфейса во время выполнения, который содержит ссылку на метод, разрешенный MethodHandle
```java
private BiConsumer createVoidHandlerLambda(Object bean, Method method) throws Throwable {
        MethodHandles.Lookup caller = MethodHandles.lookup();
        CallSite site = LambdaMetafactory.metafactory(caller,
                "accept",
                MethodType.methodType(BiConsumer.class),
                MethodType.methodType(void.class, Object.class, Object.class),
                caller.findVirtual(bean.getClass(), method.getName(),
                        MethodType.methodType(void.class, method.getParameterTypes()[0])),
                MethodType.methodType(void.class, bean.getClass(), method.getParameterTypes()[0]));
        MethodHandle factory = site.getTarget();
        BiConsumer listenerMethod = (BiConsumer) factory.invoke();
        return listenerMethod;
    }
```

## ReferenceQueue
В ней можно определить, какие `Reference` были бы убраны garbage collector-ом, а какие - нет

## VarHandle
Можно получить через `MethodHandles`<br/>
Можно делать `get`, `set`, `getAndAdd`

## Типы индексов
Частичный индекс - индекс, который строится по подмножеству строк таблицы, определяемому условным выражением
Покрывающий индекс - это некластеризованный индекс, когда все столбцы, на которые есть ссылки в запросе, являются либо частью ключа индекса, либо указаны в предложении включенных столбцов оператора создания индекса

## Комбинаторика
Сколько вариантов числа из 4 цифр включая 0?<br/>
И Если они не должны повторяться?

## О чем не забыть на задачах по архитектуре
* Кто и как будет пользоваться системой (диаграмма использования), а значит какие должны быть ЛК и у кого? Отдельные сервисы и приложения?
* Какие внешние системы мы юзаем? Payment, к примеру
* Какие системы используют наш? Нужно ли выдавать API наружу?
  * API Gateway с аутентификацией
  * проверка по ролевой модели тут?
* Нужны ли отчеты/инфографики/ прочая аналитика
* User story в формате `In order to achieve a business goal or deliver business value As a stakeholder I want something`
  * `Указать happy path` и `exceptional path`
* Интеграция через границы компонентов:
  * выгрузки файлов
  * данные в БД
  * API
  * Обмен сообщений
* Балансировка нагрузки
* Мониторинг с оповещениями для предотвращения аварий?
  * ретраи?
  * circuit breaker?
* Нужно ли кэширование? Инвалидация кэша при добавлении/изменении?
* БД на чтение и БД на запись с репликацией/синхронизацией
* Шардинг
* Описать entity
* Можно/Нужно ли продублировать какие-то entity в БД других сервисов? Если да, то нужна MQ для ивентов и джоба для синхронизации по этим ивентам
* Какая воронка
* Распределены ли географически пользователи?
* Какие-то данные типа изображений и других файлов?
  * CDN?
* endpoint-ы api
* Выбор БД
  * по нагрузке
    * Oracle - 12K rps
    * PostgreSQL - 3K rps
    * MySQL - 1K rps
* Latency
  * чтение из памяти 250мкс
  * чтение по сети 10мс
  * чтение с диска 30мс
* Доступность
  * 99% или 14.4 часа в сути, или 7,31 часа в месяц, или 3,65 дня в году
  * 99.9% или 1.44 минуты в сути, или 43,83 минуты в месяц, или 8.77 часа в году
  * 99.99% или 8.64 минуты в сути, или 4.38 минуты в месяц, или 52.6 минуты в году
* RPS = RPD / 86400

Нагрузки, ограничения и фишки решений (бд и прочие )
Healthcheck, сине зеленый деплой, откат

## Управление памятью
### Стек (Stack)
Стековая память отвечает за хранение ссылок на объекты кучи и за хранение примитивов, которые содержат само значение, а не ссылку на объект из кучи.\
Кроме того, переменные в стеке имеют областью видимости. Используются только объекты из активной области.\
Когда метод завершается и возвращается, верхняя часть стека выталкивается, и активная область видимости изменяется.\
стековая память в Java выделяется для каждого потока. Следовательно, каждый раз, когда поток создается и запускается, он имеет свою собственную стековую память и не может получить доступ к стековой памяти другого потока.

### Куча (Heap)
Эта часть памяти хранит в памяти фактические объекты, на которые ссылаются переменные из стека.\
Куча общая независимо от того, сколько потоков выполняется.

### Ключевое слово new
несет ответственность за обеспечение того, достаточно ли свободного места на куче, создавая объект нужного типа в памяти и обращаясь к нему через «builder» ссылки, которая попадает в стек.

## Можно ли автовайрить бины друг в друга и все сломать?
## LazyInitException
## Методы Throwable

